REST API란 무엇인가요?? :
API 는 어플리케이션 프로그래밍 인터페이스의 약자로, 웹이나 모바일에서 사용자가
기능을 원할하게 사용가능하게 해주는 컨트롤적인 것들을 유저인터페이스 라고 부르듯이
소프트웨어가 다른 소프트웨어로부터 지정된 형식의 명령이나 요청을 받을 수 있는 수단을
API라고 합니다.
REST API란 REST한 방식의 웹 통신 방법입니다. 따라서 REST는 어떤 방법론입니다.
인터넷에서 정보를 공유할 수 있는 방법으로 Http 와 URI 방식으로 하는것입니다.
이때 자원의 요청에 해당하는 부분만으로 어떤것을 요청하고 있는지 대강 알 수 있게 짜는것이
REST API 입니다. http 통신 방법으로는 GET/POST/PUT/DELETE 등이 있습니다.

RESTful 은 무엇인가요?? :
REST한 규약을 제대로 잘 지켜낸 것을 RESTful 하다고 합니다.
그럼 어떤 규약이 있느냐, 
첫째로 클라이언트와 서버와의 관계에 있어서 클라이언트는 서버에서 일어나는 일에 대해 알 수도 없고
알 필요도 없습니다. 서로 독립적 이어야 합니다.
둘째로 Stateless 해야합니다. 서버는 클라이언트의 세션 상태나 정보를 저장하지 않으므로 클라이언트가
요청을 보낼 때 필요한 모든 정보를 보내줘야 합니다.
셋째로 Cashe인데, 요청에 대한 응답 내의 데이터안에 요청한 모든 정보가 포함되어야 합니다.
http header 의 cashe-control 헤더를 이용합니다.
넷째는 대부분의 서비스가 restful 하지 않다고 만드는 조건인 Uniform interface 입니다.
해당 조건에는 4가지 조건이 있는데 첫째와 둘째의 조건을 요약하자면 URL로 지정한 리소스를
Http 매서드를 통해 표현하고 구분한다 입니다.
세번째와 네번째의 제약조건은 서로 연결되어 있습니다. 응답 메세지가 스스로에 대한 설명을 할 수 있어야 한다는 
내용입니다. API 명세서에 적는 내용이 그대로 응답 바디에 존재해야 한다는 것입니다. API 명세서 전체를 적지는 못해도
해당 명세서가 존재하는 곳을 알려줘야 하는데 이것을 어떻게 알려줘야 할까?
네번째 제약조건인 Hypermedia As The Engine Of Application State, 줄여서 HATEOAS에서 명시하는
하이퍼미디어인 링크를 통해 알려줘야 합니다.

-------------------------------------------------------------------

queryDsl은 왜쓰셨죠?
데이터 조회를 구현하는 과정에서 조건 조회에 해당하는 부분을 기존대로 Spirng Data JPA를 사용하려고하니
복잡한 부분에 대해서 구현 한계가 왔습니다. 이부분은 spring data jpa의 단점인 복잡한 쿼리를 구현할 수 없다는것과
일맥상통합니다.

어떤 부분 조회때문에 복잡하다는 걸까요?
이 부분을 설명드릴려면 저희 프로젝트에 대한 간단한 사전 지식이 필요합니다.
저희 프로젝트는 다같이 정적인 그림을 그리고 참여한 그림들을 모두 모아서 순서대로 한장씩 넘겨
재생하여 움직이는 그림인 gif 파일로 만들어 주는 서비스 입니다.
최초 게시물 작성자가 있고 몇개까지 그림을 그려야 완성되는지 설정할 수 있으며 설정 개수까지
다른 사람들이 게시물에 그림을 이어그려서 참가할 수 있습니다.
마이페이지 에서는 회원의 참가목록들을 볼 수 있는 카테고리가 존재하는데,
자신이 최초작성자인 게시물, 자신이 참여한 게시물, 둘다 포함된 전체보기가 있습니다.
여기에 서브카테고리로 추천순,조회순,댓글순,최신순 으로 볼 수도 있고요.
이때 자신이 참여한 게시물 조회에 문제가 있었습니다. 자신이 최초 작성자인 게시물을 빼고
자신이 다른사람의 그림에 참여한 게시물만 보이면서 추가로 차신이 숨김처리한 게시물도 빼야했습니다.
이런 부분때문에 복잡하다고 말씀드린겁니다.

Spring Data JPA와 queryDsl의 장/단점이 뭘까요?
spring data jpa의 장점은 자주쓰고 단순한 쿼리를 프로그래머가 sql 과 db사이를 연결하는 부분을
신경쓰지 않게 해줘서 비즈니스 로직에 집중할 수 있게 해줍니다. 매서드 명이 곧 기능을 하므로
직관적이고 쉽습니다.
단점은 구현하고자 하는 기능에 한계가 명확합니다. 단순하고 자주쓰는 기능들에 한해서 구현했기 때문에
연관관계가 많은 테이블에 각 관계마다 필터를 해줘야하 하는 경우처럼 복잡한 쿼리는 구현할 수 없습니다.
또한 단순한 조회라서 구현할 수 있다고 해도 만약 조회하는 경우의수가 조금만 달라져도 구현 매서드를
하나 더 생성하여야 하기때문에 많은 량의 조회를 구현하고자 한다면 그만큼 코드의 수가 증가합니다.
QueryDsl의 장점은 복잡한 쿼리를 매우 간단하게 구현할 수 있습니다. 또한 자바코드로 작성하기 때문에
컴파일 단계에서 오류가 있다면 잡아낼 수 있습니다.
단점은 외부 라이브러리 이다 보니 초기 설정하는데에 어려움이 있습니다. 쿼리팩토리에서 쓰일
엔티티 데이터를 그냥쓰는게 아니라 Q클래스로 복사하여 쓰기때문에 따로 컴파일을 해줘야 하고
이를 위해서 gradle에 설정을 잡아줘야합니다. 또한 querydsl 버전에 따라 설정하는 부분이 달라서
버전별로 잘보고 해야합니다.

queryDsl 말고 다른건 생각해보시진 않았나요?
JPA가 제공하는 것들에는 다양한것이 있다고 알고있습니다.
우선 JPQL이 있었습니다. sql을 추상화해서 사용하기 때문에 데이터베이스가 sql에 종속적이지 않아서 의존도를 낮출 수 있어서 객체지향적으로 좋습니다.
native query는 반대로 sql을 직접 쓰기 때문에 데이터베이스가 sql 에 너무 의존되어 제외했습니다.
JPQL 을 보다 쉽게 사용할 수 있도록 도와주는 것이 queryDsl 이었습니다.
JPQL은 String 으로 쿼리를 작성했기 때문에 오류가 나도 런타임시에는 알지 못합니다. queryDsl은 자바코드로 작성하기 때문에 코드작성에 오류가 있으면
바로 검출할 수 있습니다. 또한 JPQL은 파라미터 바인딩을 해줘야 하는데 queryDsl의 경우에는 자동으로 파라미터 바인딩을 해줍니다.
문법또한 queryDsl은 sql문과 매우 비슷한 구조로 이루어져있어서 이해하기 쉽습니다.
queryDsl과 마찬가지로 JPQL을 보다 편하게 작성하도록 도와주는 빌더 클래스 모음에는
Criteria 와 JOOQ 이 있었는데 Criteria의 경우에는 너무 복잡하고 장황하여 사용하기 불편하고 가독성도 매우 떨어졌습니다.

-------------------------------------------------------------------

DB잠금에 대해서 말씀해 주셨는데 무엇을 위해 쓴건지 간략히 설명해주세요.
이것을 설명드리기 위해 프로젝트의 서비스를 먼저 간략히 소개해드리겠습니다. 여러사람이 그림을 한장씩 이어그려서 끝에는 하나의 움직이는 gif 파일로
만드는 서비스입니다. 첫 게시글 작성자가 gif 로 만들어질 이어그린 그림들의 개수를 정할 수 있는데 마지막 그림이 이어그려지면 자동으로 gif 변환 과정을
거칩니다. 이때 마지막 번째 그림을 여러사람이 동시에 그리게 될때 DB에 여러장의 그림이 저장되는 문제가 있었고 이를 막기위해 트렌젝션 db 잠금을 하여 동시성제어를 하게되었습니다.

어떤 방법으로 막으셨을까요?
비관적 잠금의 베타락(x-lock) 을 사용하였습니다. 동시성 제어를 위해 낙관적 잠금에 버전체크를 채택했었는데
한사람이 여러번 참여하기 버튼을 눌러서 트랜젝션을 빠르게 연달아 하게될 경우에, 데드락 상태에 빠졌습니다.
낙관적 락은 db를 잠그는 방식이 아니라 버전체크를 통해 잠그는 척을 하는건데 왜 데드락이 걸렸는지 의아했습니다.
의도치않게 Hibernate와 InnoDB 중 한 쪽에서 락을 걸고 있음을 추측하며, SHOW ENGINE으로 데드락 문제를 진단했다.
Post 엔티티에 베타잠금과 공유잠금이 두개의 트렌젝션에 의해 걸려서 데드락에 빠진것이었는데 문제는 둘다 의도하지 않았는데
발생했다는것이었습니다. 
MySQL 공식 문서에서 동시성과 관련된 부분을 읽어보았습니다.
레코드를 수정할 때에는 InnoDB가 항상 x-lock을 건다고 합니다.
따라서 UPDATE post SET ... WHERE id=? AND version=? 구문에서 x-lock이 걸렸음을 확인할 수 있었습니다.
다른 레코드를 참조하는 새 레코드를 생성할 때, 참조하는 레코드에 s-lock을 건다고 합니다.
따라서 INSERT INTO post_registration VALUES (...) 구문에서 s-lock이 걸렸음을 확인할 수 있었습니다.
InnoDB에서는 위 잠금들을 트랜잭션 격리 수준과 관계 없이 항상 수행합니다. (READ UNCOMITTED에서도 잠금을 수행한다!)
그러므로 Foreign key 제약 조건이 있는 테이블에는 Optimistic Lock을 활용할 수 없었습니다. 이는 DB에서 Lock을 걸지 않도록 만들 방법이 없기 때문인데, Lock이 없으면 데이터의 일관성을 지키기 어렵기 때문입니다.
따라서 비관적 락을 통해 1초의 타임아웃을 거는것으로 데드락 문제를 해결했습니다.
